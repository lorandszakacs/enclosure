/*
 * Copyright 2021 Loránd Szakács
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.lorandszakacs.enclosure

/** When generated by the macro [[com.lorandszakacs.enclosure.Enclosure.generateEnclosure]], this class provides
  * information about the "enclosing scope" from where it was generated.
  *
  * @param fullModuleName
  *   Where "module" is either a:
  *   - class
  *   - object
  *   - package
  *
  * Examples:
  * {{{
  *
  * package myapp
  * import com.lorandszakacs.enclosure.Enclosure
  *
  * object Printer {
  *   def locatedPrintln(s: String)(implicit enc: Enclosure): Unit =  {
  *     println(s"[{enc.fullModuleName}] $$s")
  *   }
  * }
  *
  * //
  * package myapp.module
  *
  * object Main extends App {
  *   myapp.Printer("in main!")
  *   // prints out:
  *   // [myapp.module.Main] in main!
  *   nestedMethod()
  *   // idem
  *
  *   def nestedMethod(): Unit = {
  *     myapp.Printer("in main!")
  *   }
  * }
  *
  * }}}
  *
  * if the Enclosure is generated:
  *   - within a nested class, that is also included in the fullModuleName.
  *   - within a package (object) the name will be the package name
  */
final case class Enclosure(
    fullModuleName: String
)

object Enclosure extends internal.EnclosureMacros
